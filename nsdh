import discord
from discord import ui 
from discord.ext import commands, tasks
import pyautogui 
import time
import asyncio
import requests
import re
import flask
from flask import Flask, request, jsonify
from discord.ext import commands
import subprocess
from pywinauto import Application
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import json
import os
from datetime import datetime

intents = discord.Intents.default()
intents.members = True  # Required for member information
intents.message_content = True
intents.guilds = True
intents.guild_messages = True

client = commands.Bot(command_prefix='!', intents=intents)

emoji_id = '1298712684396548126'  # Replace with your emoji's ID
emoji_name = 'Loading'  # Replace with your emoji's name
emoji_str = f'<a:{emoji_name}:{emoji_id}>'
alertemoji = '<a:Alert:1300737080757977098>'
money1 = '<a:Money:1300736968887504906>'
verified = '<:twitterverified:1300736745461252178>'
money2 = '<a:MoneySoaring:1300736723491229767>'
paypal = '<:Paypal:1300725128274903080>'
cashapp = '<:Cashapp:1300725108821725224>'
robux = '<:Robux:1300725051431059466>'
robloxdance = '<a:Roblox_Dance:1300725016274538518>'

APPLICANTS_FILE = 'dhcinfo.json'

def load_applicants():
    if os.path.exists(APPLICANTS_FILE):
        try:
            with open(APPLICANTS_FILE, 'r') as f:
                return json.load(f)
        except json.JSONDecodeError:
            # If JSON is invalid, return an empty dictionary
            return {}
    return {}

# Save applicants to the JSON file
def save_applicants(applicants):
    with open(APPLICANTS_FILE, 'w') as f:
        json.dump(applicants, f, indent=4)

# Save a new applicant or update existing information
def save_applicant(user_id, username, dhc):
    applicants = load_applicants()  # Load existing applicants
    applicants[user_id] = {          # Add or update user information
        'username': username,
        'dhc': dhc
    }
    save_applicants(applicants)      # Save the updated data

# Retrieve user information by user ID
def get_user_info(user_id):
    applicants = load_applicants()  # Load existing applicants
    return applicants.get(user_id, None)  # Return user info or None if not found

# Delete an applicant by user ID
def delete_applicant(user_id):
    applicants = load_applicants()  # Load existing applicants
    if user_id in applicants:
        del applicants[user_id]  # Remove the user from the dictionary
        save_applicants(applicants)  # Save the updated data
        print(f"User  {user_id} has been deleted.")
    else:
        print(f"User  {user_id} not found.")

def get_user_id(name):
    try:
        response = requests.get(f'https://www.roblox.com/users/profile?username={name}')
        
        # Check to see if the response is valid
        if not response.ok:
            raise Exception("Invalid response")
        
        # Return the only digits in the URL "the User ID"
        user_id = re.search(r'\d+', response.url).group(0)
        
        # This is where you get your ID

        return user_id  # Return the user ID for further use

    except Exception as e:
        print(e)
        return None  # Return None if there was an error

INFRACTIONS_FILE = 'infractions.json'

def load_infractions():
    if os.path.exists(INFRACTIONS_FILE):
        with open(INFRACTIONS_FILE, 'r') as f:
            try:
                return json.load(f)
            except json.JSONDecodeError:
                return {}
    return {}

def save_infractions(infractions):
    with open(INFRACTIONS_FILE, 'w') as f:
        json.dump(infractions, f, indent=4)

infractions = load_infractions()

service = Service(executable_path="./chromedriver.exe")
driver = webdriver.Chrome(service=service)
driver.maximize_window()

# Navigate to Roblox (you can start with any page)
driver.get('https://www.roblox.com/users/7397498884/profile')
time.sleep(5)  # Wait for the page to load

# Define the cookie you want to add
cookie = {
    'name': '.ROBLOSECURITY',  # Replace with the actual cookie name
    'value': '_|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items.|_88A847747D1258FE59303591351F41C1B414B8A59089B1AB186B119F17BDBFBD49688C7DF2B78FCCE9CDF4342BE593DF12084AFC6D2E0BD3EE73720363B710A49189CC98094BD8BFAD552CA1C64DC6C0F17C860795FCBBBF430E72D54E8D6306571DCD316F2B5F0929A7A4304E5C58F909A0E714B1C5381B7D3F33B7D5C8486226148BF886274FBEAF15E66AA8C10CAF58887D7A96C1F649533880D566A10873EDB451A90AE55C4C454A44E1CB1942A873F9C27288AB5A709D64AE9C22D55AFAA682D39C39585AFA5DF4E563DB6E101D34905D48580393AB60A1A8D8DD17557B2D05FC026D2661F8C55CEEF40DA8360D10B8C5E64A52B93025BFF1A119D64958D6D387F979FA6CB2352B83A05DCD9ED2D422B23E44FF07B3F23869C77BEC193D78840EAB2C47C24309207475325B442796BB25CC481F787C71783EABFC9D71F8BA55ED7007AAF800AFF6A87B7BAB8141DAC9E02770716638618C711D1D94143F0353637CDFE6B18D018A5FC32031DDB315E70B24BC11E2E10B4D3A68C751832A4000DD5198E69EB1646ED9525B85DC1988C1E2D099AA30EDE73C3070EB1A98001ECB686CEA66477ECC1AD335682BBDB11FB4FCAF32FC3121E581C48B6089AFA80B24F817F15CD92458E9A34CE3FFFDD8C7FB37105F25D3BF6846DD730CBA8FC3E71E4E8E1A2311C5CB093F711248C57BAB22A0CF13597CC99EFF67F20BFFF6489B933135E1FCAA01283B37145D109A08B31304ED5BB42D81069A4E248DD69DC2D68DA5E88EFE5C62B0B08B822C7E40C95EE668D752B5A4095B9C29C1B6F0223C2D138F629433A0C7E7DE354E5F20852EACD18C6179DA246E1D9E9ADD92FA4A22A0BAA2C51082F74AD9CECF80A0AF6AC7C2ED8A828C2A50184774B3F77848A80BBABC1BECD64E57B6ABB725212703F5A4401A85F794B40490FBA0087CBCFB757B2EF96036700757DF766FC04C7CCD1C71AC8BAAA28FC9C8B6EA92FA00E8B1D12FE48D192998AEF94616D8A9A51D9EE284AA1E07C2612F5601D31B02D9F557501748C9AB8D5452AE43440B996135A63401967053F1DCEC6F4A27DB98F0D11961D28F278268636966AFA32A0A95B7DB409C6DCF75CADC52D0CBD47BBC89FB3497BEB31E70AA7F7699B66F70E1E1344A49E380206C39',  # Replace with the actual cookie value
    'domain': '.roblox.com',  # Domain for the cookie
    'path': '/',  # Path for the cookie
    'secure': True,  # If the cookie is secure
    'httpOnly': True  # If the cookie is HTTP only
}

# Add the cookie to the browser
driver.add_cookie(cookie)

# Refresh the page to apply the cookie
driver.refresh()

async def check_shirt_ownership(user_id, shirt_id):
    # Define the inventory URL
    roblox_api_url = f'https://inventory.roblox.com/v1/users/{user_id}/items/Asset/{shirt_id}'
    
    try:
        # Make the GET request
        response = requests.get(roblox_api_url)

        # Check if the request was successful
        if response.status_code == 200:
            data = response.json()
            # Check if 'data' is a non-empty list and its first element is not an empty object
            if data.get('data') and isinstance(data['data'], list) and len(data['data']) > 0 and data['data'][0]:
                return True  # User owns the shirt
            else:
                return False  # User does not own the shirt
        else:
            print(f"Error: Unable to fetch data (Status code: {response.status_code})")
            return False
    except Exception as e:
        print(f'Error checking shirt ownership: {e}')
        return False

setup_message_object = None
@client.event
async def on_ready():
    await client.change_presence(status=discord.Status.online, activity=discord.Activity(type=discord.ActivityType.listening, name='.gg/dhh'))
    print(f'We have logged in as {client.user}')
    verifymessage = "To gain access to the rest of Haven DHC please press the 'Verify' button below!"
    button3 = discord.ui.Button(label="Verify", style=discord.ButtonStyle.secondary)

    async def button3_callback(interaction):
        user_id = interaction.user.id  # Get the user ID from the interaction
        guild = interaction.guild  # Get the guild (server) where the interaction happened
        
        # Replace 'YOUR_ROLE_ID' with the actual ID of the role you want to assign
        role_id = 1314983586096746537  # Change this to the ID of the role you want to assign
        role = guild.get_role(role_id)  # Get the role by ID
        role_id1 = 1314983586721693737  # Change this to the ID of the role you want to assign
        role1 = guild.get_role(role_id1)

        if role is not None:
            user = guild.get_member(user_id)  # Fetch the user from the guild using their ID
            await user.add_roles(role)
            await user.remove_roles(role1)  # Add the role to the user
            await interaction.response.send_message("You have been verified and given the role!", ephemeral=True)
        else:
            await interaction.response.send_message("Role not found. Please contact an admin.", ephemeral=True)
    button3.callback = button3_callback
    view2 = discord.ui.View()
    view2.add_item(button3)

    channel_id2 = 1288454983712374857  # Replace with your channel ID
    channel2 = client.get_channel(channel_id2)

    await channel2.purge(limit=None)

    # Send the main embed with buttons
    await channel2.send(verifymessage, view=view2)

    embed = discord.Embed(
        title="Welcome to Haven DHC",
        description=(f'This server is completely based around the roblox game [Da Hood](https://www.roblox.com/games/2788229376/UPD-Da-Hood). We drop in-game cash for robux or paypal. The server has lots to offer from giveaways to events. Enjoy the community and please be respectful to other server members.\n'),
        color=discord.Color(0x32CD32)  # Lime green color
    )

    guild_id = 1288133914589790328  # Replace with your actual guild ID
    guild = client.get_guild(guild_id)
    server_icon_url = guild.icon.url if guild.icon else None

    # Set the author block
    embed.set_author(
        name=">> HavenDHC",  # Replace with your bot's name
        icon_url=server_icon_url,  # Bot's avatar URL
    )

    embed.set_thumbnail(url="https://cdn.discordapp.com/attachments/1288455007309660242/1288477640361115729/havendhclogo.png?ex=67179ad0&is=67164950&hm=75be69fb2ecea62dbc288556b6a89371212924124d985aceee2ad90e2b0b2ed6&")  # Replace with your icon URL
                
    embed.add_field(
        name="🌐 Quick Links", 
        value=('Twitch: [HeavenSellz](https://www.twitch.tv/heavensellz)\n'
                'Tiktok: [Heaven.Sellz](https://www.tiktok.com/@heaven.sellz)\n'
                'Youtube: [Haven_Sellz](https://www.youtube.com/@Heaven_Sellz)' 
        ),
        inline=True
    )
    embed.add_field(
        name="🌐 Information", 
        value=(
                'Founded: October 12, 2024\n'
                'Owner: <@608356252816506884>\n'
                'Discord: [Your Discord Link Here]'  # Replace with your actual Discord link if needed
        ), 
        inline=True
    )
    embed.set_footer(text="@HavenDHC")

    # Create buttons
    button1 = discord.ui.Button(label="💵Donate", url="https://www.roblox.com/users/419891712/profile", style=discord.ButtonStyle.link)
    button2 = discord.ui.Button(label="📖Info", style=discord.ButtonStyle.secondary)

    async def button2_callback(interaction):
        # Create the second additional embed
        embed2 = discord.Embed(
            title="HDHC | Information",
            description="**My Systems**\n"
            'Regarding my systems, i personally have coded/made my system/operation of dropping. My goal is to make it fully automatic, it is automatic, but not to the extent that i want it to be, when i say that, i mean that i have to personally have to verify the paypal orders, the rest is automatic especially the robux option, this option is automatic, which means i dont need to lay a finger.'
            '\n'
            '**How orders work**\n'
            'Basically you obviously make a ticket and then depending on what payment option you choose you will have to do certain thing, if you open a robux ticket, just do what the bot says, this option is automatic, but if you choose another option you will be waiting for myself to respond,(the next process is only the non automatic ones) next you will have to purchase how much you want, next i will send you the private server link, then im probably gonna be afk but keep on picking up, dont stop, my system will automatically kick you once you have picked it all up, then just take a ss of your wallet with the alt and send the ss in the vouch channel.\n'
            '\n'
            '**My pc specs**\n'
            'RTX 3060 12GB\n'
            'Intel 14th Gen Core i5-14500\n'
            '64GB 3600MHz DDR4 RAM\n'
            '\n'
            '**DHC Info**\n'
            'I run up to 30 accounts with a emulator (Mumu emulator)\n'
            '\n'
            '__MUMU Settings__\n'
            'Cores: 2\n'
            'Ram: 1.75gb\n'
            'FPS: 20\n'
            '\n'
            '**DHC Private Servers**\n'
            'The reason i take the entire weekend to farm is due to me not having enough funds to purchase over 30 private servers which cost 500 Robux, only reason why i cant afford it is being im fairly new the selling dahood cash but not with coding etc.',
            color=discord.Color(0x32CD32)
        )
        await interaction.response.send_message(embed=embed2, ephemeral=True)

    # Add callbacks to buttons
    button2.callback = button2_callback

    # Create a view and add buttons to it
    view = discord.ui.View()
    view.add_item(button1)
    view.add_item(button2)

    channel_id = 1288561881002278922  # Replace with your channel ID
    channel = client.get_channel(channel_id)
    await channel.purge(limit=None)

    # Send the main embed with buttons
    await channel.send(embed=embed, view=view)

    global setup_message_object  # Declare as global before assignment
    setup_message = (
        f"{money1} __**DHC Automation has been developed and arrived!**__\n"
        f"{verified} Once your purchase is verified by the bot __you can start your DHC order and pickup immediately!__\n"
        "\n"
        f"{cashapp} 0.5 per mil (bigger the amount = bigger the discount ex. 50m = ~~$25~~ **$20**)\n"
        f"{paypal} 0.5 per mil (bigger the amount = bigger the discount ex. 50m = ~~$25~~ **$20**)\n"
        f"{robux} 50 per mil (if you plan on ordering over 100m, your order will automatically be moved to a manual order, which in this case will automatically be a priority order)\n"
        "\n"
        f"{money2} For pricing info go to <#1288454995120754699>\n"
        f"{alertemoji} Please note, the automatic system may sometimes be unavailable. You can check if there is a server available or if auto dhc is unavailable."
    )

    button1 = discord.ui.Button(label="Robux", style=discord.ButtonStyle.green, custom_id="Robux")
    button2 = discord.ui.Button(label="Paypal", style=discord.ButtonStyle.primary, custom_id="Paypal")
    button3 = discord.ui.Button(label="Cashapp", style=discord.ButtonStyle.green, custom_id="Cashapp")
    button4 = discord.ui.Button(label="Giftcard", style=discord.ButtonStyle.secondary, custom_id="Giftcard")

    # Create a view to hold the buttons
    view = discord.ui.View()
    view.add_item(button1)
    view.add_item(button2)
    view.add_item(button3)
    view.add_item(button4)

    channel_id = 1288605822745575464  # Replace with your channel ID
    channel = client.get_channel(channel_id)
    await channel.purge(limit=None)
    setup_message_object = await channel.send(setup_message, view=view)

    while True:
        await asyncio.sleep(20)  # Wait for 10 seconds

        FLASK_APP2 = 'http://127.0.0.1:5000/refill_value'
        response = requests.get(FLASK_APP2)
        data = response.json()
        refill = data.get('refill')
        future_time2 = int(time.time()) + 21

        setup_message2 = (
                f"{money1} __**DHC Automation has been developed and arrived!**__\n"
                f"{verified} Once your purchase is verified by the bot __you can start your DHC order and pickup immediately!__\n"
                "\n"
                f"{cashapp} 0.5 per mil (bigger the amount = bigger the discount ex. 50m = ~~$25~~ **$20**)\n"
                f"{paypal} 0.5 per mil (bigger the amount = bigger the discount ex. 50m = ~~$25~~ **$20**)\n"
                f"{robux} 50 per mil (if you plan on ordering over 100m, your order will automatically be moved to a manual order, which in this case will automatically be a priority order)\n"
                "\n"
                f"{money2} For pricing info go to <#1288454995120754699>\n"
                f"{alertemoji} Please note, the automatic system may sometimes be unavailable. You can check if there is a server available or if auto dhc is unavailable below.\n"
                "\n"
                f"__**Server Info (Updating <t:{future_time2}:R>)**__"
                "\n"
                f"- All servers are unavailable. Reason: Alt Accounts are stocking up on DHC!"
        )
        if refill == 'false':  
            FLASK_APP_URL = 'http://127.0.0.1:5000/player_count'
            response = requests.get(FLASK_APP_URL)
            data = response.json()
            player_count = data.get('playerCount')
            future_time = int(time.time()) + 21

            setup_message4 = (
                f"{money1} __**DHC Automation has been developed and arrived!**__\n"
                f"{verified} Once your purchase is verified by the bot __you can start your DHC order and pickup immediately!__\n"
                "\n"
                f"{cashapp} 0.5 per mil (bigger the amount = bigger the discount ex. 50m = ~~$25~~ **$20**)\n"
                f"{paypal} 0.5 per mil (bigger the amount = bigger the discount ex. 50m = ~~$25~~ **$20**)\n"
                f"{robux} 50 per mil (if you plan on ordering over 100m, your order will automatically be moved to a manual order, which in this case will automatically be a priority order)\n"
                "\n"
                f"{money2} For pricing info go to <#1288454995120754699>\n"
                f"{alertemoji} Please note, the automatic system may sometimes be unavailable. You can check if there is a server available or if auto dhc is unavailable below.\n"
                "\n"
                f"__**Server Info (Updating <t:{future_time}:R>)**__"
                "\n"
                f"- {robloxdance} **Server 1** - Available"
            )
            setup_message3 = (
                f"{money1} __**DHC Automation has been developed and arrived!**__\n"
                f"{verified} Once your purchase is verified by the bot __you can start your DHC order and pickup immediately!__\n"
                "\n"
                f"{cashapp} 0.5 per mil (bigger the amount = bigger the discount ex. 50m = ~~$25~~ **$20**)\n"
                f"{paypal} 0.5 per mil (bigger the amount = bigger the discount ex. 50m = ~~$25~~ **$20**)\n"
                f"{robux} 50 per mil (if you plan on ordering over 100m, your order will automatically be moved to a manual order, which in this case will automatically be a priority order)\n"
                "\n"
                f"{money2} For pricing info go to <#1288454995120754699>\n"
                f"{alertemoji} Please note, the automatic system may sometimes be unavailable. You can check if there is a server available or if auto dhc is unavailable below.\n"
                "\n"
                f"__**Server Info (Updating <t:{future_time}:R>)**__"
                "\n"
                f"- {robloxdance} **Server 1** - Unavailable"
            )
            try:
                # Edit the message based on player count
                if player_count == 0:
                    button1 = discord.ui.Button(label="Robux", style=discord.ButtonStyle.green, custom_id="Robux")
                    button2 = discord.ui.Button(label="Paypal", style=discord.ButtonStyle.primary, custom_id="Paypal")
                    button3 = discord.ui.Button(label="Cashapp", style=discord.ButtonStyle.green, custom_id="Cashapp")
                    button4 = discord.ui.Button(label="Giftcard", style=discord.ButtonStyle.secondary, custom_id="Giftcard")

                    # Create a view to hold the buttons
                    view = discord.ui.View()
                    view.add_item(button1)
                    view.add_item(button2)
                    view.add_item(button3)
                    view.add_item(button4)
                    await setup_message_object.edit(content=setup_message4, view=view)
                elif player_count == 1:
                    button1 = discord.ui.Button(label="Robux", style=discord.ButtonStyle.green, disabled=True, custom_id="Robux")
                    button2 = discord.ui.Button(label="Paypal", style=discord.ButtonStyle.primary, disabled=True, custom_id="Paypal")
                    button3 = discord.ui.Button(label="Cashapp", style=discord.ButtonStyle.green, disabled=True, custom_id="Cashapp")
                    button4 = discord.ui.Button(label="Giftcard", style=discord.ButtonStyle.secondary, disabled=True, custom_id="Giftcard")

                    # Create a view to hold the buttons
                    view = discord.ui.View()
                    view.add_item(button1)
                    view.add_item(button2)
                    view.add_item(button3)
                    view.add_item(button4)
                    await setup_message_object.edit(content=setup_message3, view=view)
                else:
                    print(f"Player count is neither 0 nor 1, handling accordingly.{player_count}")
            except Exception as e:
                print(f"Error editing message: {e}")

        elif refill == 'true':
            button1 = discord.ui.Button(label="Robux", style=discord.ButtonStyle.green, disabled=True, custom_id="Robux")
            button2 = discord.ui.Button(label="Paypal", style=discord.ButtonStyle.primary, disabled=True, custom_id="Paypal")
            button3 = discord.ui.Button(label="Cashapp", style=discord.ButtonStyle.green, disabled=True, custom_id="Cashapp")
            button4 = discord.ui.Button(label="Giftcard", style=discord.ButtonStyle.secondary, disabled=True, custom_id="Giftcard")

            # Create a view to hold the buttons
            view = discord.ui.View()
            view.add_item(button1)
            view.add_item(button2)
            view.add_item(button3)
            view.add_item(button4)
            await setup_message_object.edit(content=setup_message2, view=view)

@client.event
async def on_member_join(member):
    channel = client.get_channel(1288454990569934921)  # Replace with your channel ID
    embed = discord.Embed(title=f"Welcome {member.name}!", description=f"Thanks for joining {member.guild.name}!", color=discord.Color.green())
    embed.add_field(name="Want to buy dhc?", value="Currently DHC is down and will only be available once announced!")
    
    # Use the new way to get the avatar URL
    if member.avatar:  # Check if the member has an avatar
        embed.set_thumbnail(url=member.avatar.url)  # Set the embed's thumbnail to the member's avatar image
    
    await channel.send(embed=embed)

    user_id = member.id  # Get the user ID from the interaction
    guild = member.guild  # Get the guild (server) where the interaction happened
        
    # Replace 'YOUR_ROLE_ID' with the actual ID of the role you want to assign
    role_id2 = 1314983560763146250  # Change this to the ID of the role you want to assign
    role2 = guild.get_role(role_id2)  # Get the role by ID  # Fetch the user from the guild using their ID
    role_id = 1314983586721693737  # Change this to the ID of the role you want to assign
    role = guild.get_role(role_id)  # Get the role by ID
    user = guild.get_member(user_id)  # Fetch the user from the guild using their ID
    await user.add_roles(role)  # Add the role to the user
    await user.add_roles(role2)

@client.command()
async def dhc(ctx, amount_of_alts, amount_of_dhc: str):
    verifiedrole_id = 1314983586096746537
    is_verified = any(role.id == verifiedrole_id for role in ctx.author.roles)
    if is_verified:
        try:

            # Constants
            time_per_million_seconds = 29 * 60 + 24  # 1764 seconds for 1 million DHC

            # Total time for one alt to drop the specified amount of DHC
            total_time_seconds = (time_per_million_seconds * amount_of_dhc) / amount_of_alts

            # Convert total time from seconds to hours, minutes, seconds
            hours = total_time_seconds // 3600
            minutes = (total_time_seconds % 3600) // 60
            seconds = total_time_seconds % 60
            # Create a response message
            response = (f"It will take approximately {int(hours)} hours, "
                        f"{int(minutes)} minutes, and "
                        f"{int(seconds)} seconds for {amount_of_alts} alts to drop {amount_of_dhc} million DHC.")
                
            await ctx.reply(response)
        
        except (IndexError, ValueError):
            await ctx.reply('Please provide valid numbers for alts and DHC. Usage: `.dhc (amount of alts) (amount of dhc)`')
    else:
        await ctx.reply('You do not have the required role to use this command.')

@client.command()
async def refill(ctx, option: str):
    ownerrole_id = 1314983505519837214
    is_owner = any(role.id == ownerrole_id for role in ctx.author.roles)
    if is_owner:
        try:
            if option == 'on':
                data = {'refill': 'true'}
                response = requests.post('http://127.0.0.1:5000/endpoint2', json=data)

            elif option == 'off':
                data = {'refill': 'false'}
                response = requests.post('http://127.0.0.1:5000/endpoint2', json=data)

            else:
                await ctx.reply("Invalid option. Use 'on' or 'off'.")

        except (IndexError, ValueError):
            await ctx.reply("Please provide a valid option: 'on' or 'off'.")
    else:
        await ctx.reply('You do not have the required role to use this command.')

@client.command()
async def price(ctx, amount: str):
    verifiedrole_id = 1314983586096746537
    is_verified = any(role.id == verifiedrole_id for role in ctx.author.roles)
    if is_verified:
        try:
            # Define the price values
            robux_per_dhc = 50
            usd_per_dhc = 0.50

            # Calculate total prices
            total_robux = amount * robux_per_dhc
            total_usd = amount * usd_per_dhc

            # Create the response message
            response = f"Robux: R{total_robux}, USD Price: ${total_usd:.2f}\n"

            # Send the response
            await ctx.channel.send(response)
        except (ValueError, IndexError):
            await ctx.channel.send("Please provide a valid number of DHC. Usage: `.dhcprice <amount>`")
    else:
        await ctx.reply('You do not have the required role to use this command.')

@client.command()
async def commands(ctx: str):
    verifiedrole_id = 1314983586096746537
    is_verified = any(role.id == verifiedrole_id for role in ctx.author.roles)
    if is_verified:

        guild = ctx.guild
        
        # Get the server logo (icon) URL
        server_icon_url = guild.icon.url if guild.icon else None

        embed = discord.Embed(
        
        description=("**Commands**\n"
                    "Most of these commands are not usable to the public but 1-3 are!"),
        color=discord.Color.green()  # You can choose any color
        )

        # Set the author block
        embed.set_author(
        name=">> HavenDHC",  # Replace with your bot's name
        icon_url=server_icon_url,  # Bot's avatar URL
        )

        embed.set_thumbnail(url="https://cdn.discordapp.com/attachments/1288455007309660242/1288477640361115729/havendhclogo.png?ex=67179ad0&is=67164950&hm=75be69fb2ecea62dbc288556b6a89371212924124d985aceee2ad90e2b0b2ed6&")  # Replace with your icon URL
        
        # Add fields to the embed
        embed.add_field(name="Commands", value=('**.drop on/off**\n'
                                                '**.dhc**\n'
                                                '**.setupalts**\n'
                                                '**.setgoal**\n'
                                                '**.setup club**\n'
                                                '**.airlock**\n'
                                                '\n'
                                                '**.info**\n'
                                                '**.commands**'), inline=True)
        embed.add_field(name="Uses", value=('Drops dhc and stops dropping dhc\n'
                                            'Calculates the time to drop dhc\n'
                                            'Sets up the mumus for the alts\n'
                                            'Sets a users dhc goal manually\n'
                                            'Automatically sets up the alts in club\n'
                                            'Automatically puts the alts in airlock or out of airlock\n'
                                            'Shows the info of the bot\n'
                                            'Shows all the commands'), inline=True)
        embed.set_footer(text="@HavenDHC")
        
        # Send the embed as a reply
        await ctx.reply(embed=embed)

@client.command()
async def botinfo(ctx: str):
    botinfotext = (
        "**Version:** 1.05.7\n"
        "**Servers:** 1\n"
        "**Made:** <t:1729353300:R>"
    )
    botextrainfo = (
        "**Developer:** <@608356252816506884>\n"
        "More Soon\n"
        "More Soon"
    )
    bot = commands.Bot(command_prefix='.', intents=intents)

    guild = ctx.guild
        
    # Get the server logo (icon) URL
    server_icon_url = guild.icon.url if guild.icon else None

    embed = discord.Embed(
        
    description=("**About**\n"
                "This bot helps HeavenSellz with selling dhc. What this bot does is basically controls HeavenSellz pc to do automatic orders!"),
    color=discord.Color.green()  # You can choose any color
    )

    # Set the author block
    embed.set_author(
    name="HavenDHC",  # Replace with your bot's name
    icon_url=server_icon_url,  # Bot's avatar URL
    )

    embed.set_thumbnail(url="https://cdn.discordapp.com/attachments/1288455007309660242/1288477640361115729/havendhclogo.png?ex=67179ad0&is=67164950&hm=75be69fb2ecea62dbc288556b6a89371212924124d985aceee2ad90e2b0b2ed6&")  # Replace with your icon URL
        
    # Add fields to the embed
    embed.add_field(name="Bot Information", value=botinfotext, inline=True)
    embed.add_field(name="Extra Information", value=botextrainfo, inline=True)
    embed.set_footer(text="@HavenDHC")
        
    # Send the embed as a reply
    await ctx.reply(embed=embed)

class Questionnaire(ui.Modal, title='Please Fill This Out!'):
    def __init__(self, user_id):
        super().__init__()
        self.user_id = user_id  # Store the user ID
        
        # Define the input fields
        self.name = ui.TextInput(
            label='Username (Not display name)',
            placeholder='This is the user that is picking the dhc',
            style=discord.TextStyle.short
        )
        self.answer = ui.TextInput(
            label='DHC Amount',
            placeholder='e.g. 5m',
            style=discord.TextStyle.short
        )

        # Add the input fields to the modal
        self.add_item(self.name)
        self.add_item(self.answer)

    async def on_submit(self, interaction: discord.Interaction): 
        # Store submitted values
        username = self.name.value
        dhc_amount = self.answer.value

        # Handle button creation and ticket generation
        await self.create_ticket(interaction, username, dhc_amount)

    async def create_ticket(self, interaction, username, dhc_amount):
        user_id = interaction.user.id
        username = self.name.value
        dhc = self.answer.value
        robloxid = get_user_id(username)

        # Define the mapping of DHC amounts to shirt IDs
        shirt_id_mapping = {
            '1m': 83076667357447,
            '2m': 99169182512960,
            '3m': 99169182512960,
            '4m': 99169182512960,
            '5m': 99169182512960
        }

        shirt_id = shirt_id_mapping.get(dhc_amount)
        if shirt_id is None:
            await interaction.response.send_message('Invalid DHC amount. Please contact the admin for your shirt ID.', ephemeral=True)
            return

        shirt_link = f'https://www.roblox.com/catalog/{shirt_id}/Haven-DHC-Shirt'
        roblox_api_url = f'https://inventory.roblox.com/v1/users/{robloxid}/items/Asset/{shirt_id}'

        # Notify the user that the order is being processed
        await interaction.response.send_message(f'{emoji_str} Please wait while we process your order!', ephemeral=True)

        # Check if the user already owns the shirt
        response = requests.get(roblox_api_url)
        if response.status_code == 200:
            data = response.json()
            if data.get('data') and isinstance(data['data'], list) and len(data['data']) > 0 and data['data'][0]:
                time.sleep(10)
                await interaction.edit_original_response(content=f'You already own the shirt, please delete it and try again! **[Shirt Link!]({shirt_link})**')
            else:
                save_applicant(user_id, username, dhc)
                # Create a channel in a specific category
                category_id = 1288454977202688022  # Replace with your category ID
                category = interaction.guild.get_channel(category_id)

                # Create a new text channel
                overwrites = {
                    interaction.guild.default_role: discord.PermissionOverwrite(read_messages=False, view_channel=False),
                    interaction.user: discord.PermissionOverwrite(read_messages=True, view_channel=True)
                }

                ticket_channel = await interaction.guild.create_text_channel(
                    name=f'・Robux-{interaction.user.name}',
                    category=category,
                    overwrites=overwrites
                )
                await interaction.edit_original_response(content=f'Thanks for creating a ticket! <#{ticket_channel.id}>')

                # Prepare the embed and buttons
                embed = discord.Embed(
                    title=f"{robux} `` ROBUX ``",
                    description=">>> ## ``1)`` **Buy the shirt linked in the `Shirt Link` button below.**\n\n## ``2)`` **Click the `Verify Order` button.**",
                    color=discord.Color.green()
                )
                embed.set_footer(text="FYI the bot has already checked if you already own the shirt, so if your seeing this, you are not trying to scam CONGRATS!")

                view = discord.ui.View()
                view.add_item(discord.ui.Button(label='1.', style=discord.ButtonStyle.blurple, disabled=True, row=0))
                view.add_item(discord.ui.Button(label='Verify Order', custom_id='verifyorder', style=discord.ButtonStyle.green, row=0))
                view.add_item(discord.ui.Button(label='2.', style=discord.ButtonStyle.blurple, disabled=True, row=1))
                view.add_item(discord.ui.Button(label=f'Shirt Link >> {self.answer.value}', style=discord.ButtonStyle.link, url=shirt_link, row=1))
                view.add_item(discord.ui.Button(label='Close Ticket', custom_id='closeticket', style=discord.ButtonStyle.red, row=2))

                # Send the message with the buttons in the new channel
                ticket_message = await ticket_channel.send(embed=embed, view=view)
        else:
            await interaction.followup.send(f"Error: Unable to fetch data (Status code: {response.status_code})")

@client.event
async def on_interaction(interaction):
    if interaction.type == discord.InteractionType.component:
        button_id = interaction.data.get('custom_id')
        
        required_role_id = 1297576099190014097
        has_role = any(role.id == required_role_id for role in interaction.user.roles)

        required_role_id2 = 1288454963152027698
        has_role2 = any(role.id == required_role_id2 for role in interaction.user.roles)

        if button_id == 'Robux':
            if has_role:
                modal = Questionnaire(interaction.user.id)
                await interaction.response.send_modal(modal)

        elif button_id == 'closeticket':
            if has_role2:
                user_id = interaction.user.id
                ticket_channel = interaction.channel
            
                # Create an embed for logging
                embed = discord.Embed(
                    title=f"{robux} `` Ticket Closed ``",
                    description=f'Ticket {ticket_channel.name} has been closed by {interaction.user.name}.',
                    color=discord.Color.green(),
                    timestamp=discord.utils.utcnow()  # Set the timestamp to the current time
                )

                # Use the channel ID to fetch the log channel
                log_channel_id = 1288508918288486441  # Replace with your actual log channel ID
                log_channel = client.get_channel(log_channel_id)

                if log_channel:
                    await log_channel.send(embed=embed)

                # Optionally, send a confirmation message in the ticket channel
                await interaction.response.send_message("This ticket is now closed. Thank you for reaching out!")
                time.sleep(10)
                await ticket_channel.delete()  # or archive it if needed
                delete_applicant(f"{user_id}")
            else:
                await interaction.response.send_message("You do not have permission to close this ticket.", ephemeral=True)

        elif button_id == 'verifyorder':
            if has_role:
                user_id = interaction.user.id
                user_info = get_user_info(f"{user_id}")
                username = f'{user_info['username']}'
                dhc_amount = f'{user_info['dhc']}'
                robloxid = get_user_id(username)

                # Define the mapping of DHC amounts to shirt IDs
                shirt_id_mapping = {
                    '1m': 83076667357447,
                    '2m': 99169182512960,
                    '3m': 99169182512960,
                    '4m': 99169182512960,
                    '5m': 99169182512960
                }

                shirt_id = shirt_id_mapping.get(dhc_amount)
                if shirt_id is None:
                    await interaction.response.send_message('Invalid DHC amount. Please contact the admin for your shirt ID.', ephemeral=True)
                    return

                shirt_link = f'https://www.roblox.com/catalog/{shirt_id}/Haven-DHC-Shirt'
                roblox_api_url = f'https://inventory.roblox.com/v1/users/{robloxid}/items/Asset/{shirt_id}'

                # Notify the user that the order is being processed
                await interaction.response.send_message(f'{emoji_str} We are currently verifying the purchase!')

                # Check if the user already owns the shirt
                response = requests.get(roblox_api_url)
                if response.status_code == 200:
                    data = response.json()
                    if data.get('data') and isinstance(data['data'], list) and len(data['data']) > 0 and data['data'][0]:
                        embed = discord.Embed(
                            title=f"{robux} `` ROBUX ``",
                            description=">>> ## ``1)`` **Start Order:**\nOnly press 'Start Order' if you know you can join private servers with a link\n\n## ``2)`` **Add Friend:**\nOnly press 'Add Friend' if you cannot join private servers with a link and only with friends",
                            color=discord.Color.green()
                        )

                        view = discord.ui.View()
                        view.add_item(discord.ui.Button(label='1.', style=discord.ButtonStyle.blurple, disabled=True, row=0))
                        view.add_item(discord.ui.Button(label='Start Order', custom_id='startorder', style=discord.ButtonStyle.green, row=0))
                        view.add_item(discord.ui.Button(label='2.', style=discord.ButtonStyle.blurple, disabled=True, row=1))
                        view.add_item(discord.ui.Button(label=f'Add Friend', custom_id='addfriend', style=discord.ButtonStyle.red, row=1))
                        view.add_item(discord.ui.Button(label='Close Ticket', custom_id='closeticket', style=discord.ButtonStyle.red, row=2))

                        # Send the message with the buttons in the new channel
                        time.sleep(10)
                        await interaction.edit_original_response(content=f'{verified} Succesfully Verified!', embed=embed, view=view)
                    else:
                        await interaction.edit_original_response(content=f'{emoji_str} You did not purchase the shirt, please buy it and retry!')
                else:
                    await interaction.followup.send(f"Error: Unable to fetch data (Status code: {response.status_code})")

        elif button_id == 'startorder':
            user_id = interaction.user.id
            user_info = get_user_info(f"{user_id}")
            username = f'{user_info['username']}'
            dhc_amount = f'{user_info['dhc']}'
            robloxid = get_user_id(username)
            await interaction.followup.send(f'{emoji_str} Setting Goal for {username} ({dhc_amount} DHC)')
        
        elif button_id == 'addfriend':
            embed = discord.Embed(
                title=f"{robux} `` ROBUX ``",
                description=">>> ## ``1)`` **Friend the bot account linked in the `Account Link` button below.**\n\n## ``2)`` **Click the `done` button and join the bot account.**",
                color=discord.Color.green()
            )

            view = discord.ui.View()
            view.add_item(discord.ui.Button(label='1.', style=discord.ButtonStyle.blurple, disabled=True, row=0))
            view.add_item(discord.ui.Button(label='Done', custom_id='done', style=discord.ButtonStyle.green, row=0))
            view.add_item(discord.ui.Button(label='2.', style=discord.ButtonStyle.blurple, disabled=True, row=1))
            view.add_item(discord.ui.Button(label=f'Account Link', style=discord.ButtonStyle.link, url='https://www.roblox.com/users/7397498884/profile', row=1))
            view.add_item(discord.ui.Button(label='Close Ticket', custom_id='closeticket', style=discord.ButtonStyle.red, row=2))
            await interaction.response.send_message(embed=embed, view=view)

        elif button_id == 'done':
            if len(driver.window_handles) > 1:
                current_time = int(time.time())
                future_time = current_time + 30
                time.sleep(5)
                await interaction.response.send_message(f'There is another user currently being added, please try again in <t:{future_time}:R>.')
                return
            await interaction.response.send_message('We are currently verifying that you have added the account')
            user_id = interaction.user.id
            user_info = get_user_info(f"{user_id}")
            username = f'{user_info['username']}'
            dhc_amount = f'{user_info['dhc']}'
            robloxid = get_user_id(username)
            # Navigate to the user's profile
            driver.execute_script(f"window.open('https://www.roblox.com/users/{robloxid}/profile', '_blank');")
            driver.switch_to.window(driver.window_handles[1])
            time.sleep(7)
            button = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.CLASS_NAME, "btn-friends"))
            )

            button_text = button.text
            if button_text == "Accept":
                button = WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located((By.CLASS_NAME, "btn-friends"))
                )
                button.click()

                time.sleep(30)
                # Wait for the button to be present and click it
                button1 = WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located((By.ID, "unfriend-btn"))
                )
                button1.click()
                driver.close()
                driver.switch_to.window(driver.window_handles[0])
                delete_applicant(f"{user_id}")
                await interaction.edit_original_response(content=f'{verified} We have succesfully accepted your account! Join the private server through friends and dont stop picking up')
                await interaction.followup.send(f'{emoji_str} Setting Goal for {username} ({dhc_amount} DHC)')
            elif button_text == "Add Friend":
                await interaction.response.send_message(f'{alertemoji} You have not added the account, please add the account and try again')
            else:
                await interaction.response.send_message(f'{alertemoji} You have not added the account, please add the account and try again')

client.run('MTI5NzA5MDg0NTg5NTU2MTIzNw.G4hMF8.my4yAEoL2XTCT5lzNwb_qBgynZseODrj5IPVXA')
